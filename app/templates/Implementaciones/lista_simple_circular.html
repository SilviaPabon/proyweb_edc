{% extends 'code_layout.html' %}

{% block title %}LISTA SIMPLEMENTE CIRCULAR{% endblock %}

{% block titulo_1 %}CÓDIGO DEL NODO:{% endblock %}
{%block node_code%}
// --- ESTRUCTURA DEL NODO ---
struct Node{
    int info;
    struct Node* next;
};
typedef struct Node node;

node *createNode(int n){
    node *new_node = malloc(sizeof(node));
    new_node->info = n;
    new_node->next = NULL;
    return new_node;
}

int getInfo(node *node){
    return node->info;
}
{% endblock %}

{% block titulo_2 %}CÓDIGO DE LA LISTA SIMPLEMENTE CIRCULAR{% endblock %}
{%block structure_code%}
// --- ESTRUCTURA DE LA LINKEDLIST ---

struct CircLinkedList{
    node *head;
    node *tail;
    int size;
};
typedef struct CircLinkedList CircLinkedList;

bool isEmpty(CircLinkedList *list){
    return (list->head == NULL);
}

int getHead(CircLinkedList *list){
    if (isEmpty(list)){
        printf("Empty, head isn't exist\n");
        return -1;
    }
    return list->head->info;
}

int getTail(CircLinkedList *list){
    if (isEmpty(list)){
        printf("Empty, tail isn't exist\n");
        return -1;
    }
    return list->tail->info;
}

int getSize(CircLinkedList *list){
    if(list == NULL){
        return 0;
    } else {
        return list->size;
    }
}

bool contains(CircLinkedList *list, int val){
    if(isEmpty(list)){
        return false;
    } else {
        node *newNode = list->head;
        do{
            if (newNode->info == val){
                return true;
            }
            newNode = newNode->next;
        } while (newNode != list->head);
        return false;
    }
}

node* search(CircLinkedList *list, int val){
    if(isEmpty(list)){
        return NULL;
    }else{
        node* aux = {NULL};
        if (contains(list, val)){
            node* aux = list->head;
            do{
                if (getInfo(aux) == val){
                    return aux;
                }
                aux = aux->next;
            } while (aux != list->head);
        } else {
            return NULL;
        }
    }
}

bool insertHead(CircLinkedList *list, int val){
    node *newNode = createNode(val);

    if (isEmpty(list)){
        list->head = newNode;
        list->tail = list->head;
    } else {
        newNode->next = list->head;
        list->head = newNode;
    }
    list->tail->next = list->head;
    list->size++;
    return true;
}

bool insertTail(CircLinkedList *list, int val){

    node *newNode = createNode(val);

    if (isEmpty(list)){
        list->head = newNode;
        list->tail = list->head;
    } else {
        list->tail->next = newNode;
        list->tail = newNode;
    }
    list->tail->next = list->head;
    list->size++;
    return true;
}

bool insert(CircLinkedList *list, int val){
    return insertTail(list, val);
}

bool insertAt(CircLinkedList* list, int index, int ingresar){
    node *newNode = createNode(ingresar);
    node *actual = list->head;
    if (isEmpty(list)){
        if(index != 0){
            return false;
        }else{
            insert(list, ingresar);
            return true;
        }
    }
    else if (!isEmpty(list) && index >= (getSize(list) + 2) ){
        printf("Impossible\n");
        return false;
    }
    else if(!isEmpty(list) && index == 0){
        insertHead(list, ingresar);
        return true;
    }
    else if(!isEmpty(list) && index == (getSize(list))){
        insertTail(list, ingresar);
        return true;
    }
    node* prev = {NULL};
    int c = 0;
    while (c < index){
        prev = actual;
        actual = actual->next;
        if(actual == NULL){
            break;
        }
        c++;
    }
    newNode->next = actual;
    prev->next = newNode;
    list->size++;
    return true;
}

bool clear(CircLinkedList *list){
    if (isEmpty(list)){
        return false;
    } else {
        node *temp = {NULL};
        while (list->size != 0){
            temp = list->head;
            list->head = list->head->next;
            free(temp);
            list->size--;
        }
        list->head = NULL;
        list->tail = NULL;
        return true;
    }
}

bool removeElement(CircLinkedList* list, int erase){
    if(!isEmpty(list)){
        node *tmp = {NULL};
        if(contains(list, erase)){
            if(list->head->info == erase && list->head == list->tail) {
                clear(list);
            } else if(list->head->info == erase){
                tmp = list->head;
                list->head = list->head->next;
                free(tmp);
                list->tail->next = list->head;
                list->size--;
            } else {
                node *prev = list->head;
                tmp = list->head->next;
                while (tmp->info != erase){
                    prev = prev->next;
                    tmp = tmp->next;
                }
                prev->next = tmp->next;
                if(tmp == list->head){
                    list->tail = prev;
                }
                list->size--;
            }

        }else{
            printf("This element isn't exist in the list\n");
        }
    }else{
        printf("Nothing to erase\n");
        return false;
    }
}

bool toArray(CircLinkedList* list, int array[]){
    if(isEmpty(list)){
        return false;
    }else {
        int index = 0;  // Contador para insertar los datos en el array
        node *actual = list->head;   // Nodo para iterar la lista
        do {
            array[index] = actual->info;   // Se insertar el dato actual en el array
            actual = actual->next;    // Se cambia el nodo actual
            index++;
        } while (actual != list->head);
        return true;
    }
}

CircLinkedList reverse(CircLinkedList* list){
    if(isEmpty(list)){
        printf("Empty list\n");
    }else {
        int array[getSize(list)];
        int size = getSize(list);
        toArray(list, array);

        clear(list);
        for (int j = 0; j < size; j++) {
            insertHead(list, array[j]);
        }
        return *list;
    }
}
//Es un apuntador void para que sea de cualquier tipo
//su retorno es 0 si son iguales
int comparison(const void * a, const void * b) {
    return ( *(int*)a - *(int*)b );
}

CircLinkedList sort(CircLinkedList* list){
    if(isEmpty(list)){
        printf("Empty list\n");
    }else {
        int array[getSize(list)];
        int size = getSize(list);
        toArray(list, array);
        qsort(array, getSize(list), sizeof(int), comparison);
        clear(list);
        for (int j = 0; j < size; j++) {
            insert(list, array[j]);
        }
        return *list;
    }
}

void displayList(CircLinkedList* list)
{
    if(isEmpty(list)){
        printf("It's empty!\n");
    }
    node *tmp = list->head;
    do{
        printf(" Info = %d\n", tmp->info);
        tmp = tmp->next;
    }
    while(tmp != list->head);
}

void printList(CircLinkedList *list){
    if(isEmpty(list)){
        printf("Empty List\n");
    }else{
        displayList(list);
    }
}
{% endblock %}

{% block table_content %}
<tr>
    <th scope="row">1</th>
    <td>Título/Descripción</td>
    <td>Same references of partner</td>
</tr>
<tr>
    <th scope="row">2</th>
    <td>Título/Descripción - Delete list</td>
    <td>https://codeforwin.org/2015/09/c-program-to-delete-all-nodes-of-singly-linked-list.html</td>
</tr>
<tr>
    <th scope="row">3</th>
    <td>Título/Descripción</td>
    <td>https://www.codingame.com/playgrounds/6991/linked-list-insertion-at-nth-position</td>
</tr>
<tr>
    <th scope="row">4</th>
    <td>Título/Descripción</td>
    <td>Cairó</td>
</tr>
<tr>
    <th scope="row">5</th>
    <td>Título/Descripción</td>
    <td>https://www.log2base2.com/data-structures/linked-list/deleting-a-node-in-linked-list.html</td>
</tr>
<tr>
    <th scope="row">6</th>
    <td>Título/Descripción</td>
    <td>https://www.gnu.org/software/libc/manual/html_node/Array-Sort-Function.html</td>
</tr>
{% endblock %}