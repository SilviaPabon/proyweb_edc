{% extends 'code_layout.html' %}

{% block title %}LISTA SIMPLE PC{% endblock %}

{% block titulo_1 %}CÓDIGO DEL NODO:{% endblock %}
{%block node_code%}
struct node{
    int data;
    struct node *next;
};

// ***** Simulación de los getters *****

int getData(struct node *NODE){
    return NODE->data;
}

struct node* getNext(struct node *NODE){
    return NODE->next;
}

// ***** MÉTODOS DE CREACIÓN Y DESTRUCCIÓN *****
struct node* createNode(int data){
    struct node *new_node = malloc(sizeof(struct node));    //Se reserva el espacio en memoria que abarca la estructura
    new_node->data = data;
    new_node->next = NULL;
    return new_node;    //Se retorna el apuntador al nuevo nodo
}

void destroyNode(struct node *NODE){    //Método para eliminar un nodo
    free(NODE);     //Libera el espacio de memoria que estaba reservado para el nodo
}

// ***** Otros métodos *****

bool isEqual(struct node *NODE, int DATA) {   //Método para saber si un nodo contiene un dato dado
    return NODE->next == DATA;
}

void nodeToString(struct node *NODE){        //Método para imprimir los nodos en cadena
    if(NODE->next != NULL){ //Si tiene un siguiente nodo
        printf("Node: Data %d, Next: ->\n", NODE->data);
        nodeToString(NODE->next);
    }else{
        printf("Node: Data %d, Next: -> NULL", NODE->data);
    }
}
{% endblock %}

{% block titulo_2 %}CÓDIGO DE LA LISTA SIMPLEMENTE ENLAZADA{% endblock %}
{%block structure_code%}
struct SimpleLinkedList{
    int size;
    struct node *head;
    struct node *tail;
};

// ***** SIMULACIÓN GETTERS *****
int getSize(struct SimpleLinkedList *LIST){
    return LIST->size;
}

struct node* getHead(struct SimpleLinkedList *LIST){
    return LIST->head;
}

struct node* getTail(struct SimpleLinkedList *LIST){
    return LIST->tail;
}

bool isEmpty(struct SimpleLinkedList *LIST){     //Método para saber si la lista está vacía
    return (LIST->head == NULL);    //SI la cabeza es nula, retorna true
}

// ***** MÉTODOS DE INSERCIÓN ****
void insertAtHead(struct SimpleLinkedList *LIST, int NEW_DATA){  //Método par insertar un dato al inicio de la lista

    struct node *NEW_NODE = createNode(NEW_DATA);

    if(isEmpty(LIST)){   //En caso de que aún no exista ningún elemento en la lista
        LIST->head = NEW_NODE;
        LIST->tail = LIST->head;    //La cabeza y la cola serán el mismo nodo
    }else{  //En caso de que ya existan elementos
        NEW_NODE->next = LIST->head;    //El siguiente nodo al nuevo nodo será la anterior cabeza
        LIST->head = NEW_NODE;          //El nuevo nodo será la cabeza de la lista
    }

    LIST->size++;   //Al finalizar cualquiera de los casos, se aumenta el size de la lista

}

void insertAtTail(struct SimpleLinkedList *LIST, int NEW_DATA){        //Método por defecto para insertar un elemento en la lista

    struct node *new_node = createNode(NEW_DATA);

    if(isEmpty(LIST)){  //Si la lista está vacía
        LIST->head = new_node;     //Como no hay más elementos, tanto la cabeza como la cola apuntan al nuevo nodo
        LIST->tail = LIST->head;
    }else{
        LIST->tail->next = new_node;   //El siguiente nodo a la cola actual es el nuevo nodo
        LIST->tail = new_node;         //La nueva cola será el nuevo nodo ingresado
    }

    LIST->size++;   //Al finalizar cualquiera de los casos, se aumenta el size de la lista

}

void insert(struct SimpleLinkedList *LIST, int NEW_DATA){        //Método por defecto para insertar un elemento en la lista
    insertAtTail(LIST, NEW_DATA);   //Se llama al método para insertar el dato al final de la lista
}

// ***** Otros métodos *****

void clear(struct SimpleLinkedList *LIST){       //Función para anular la lista

    if(LIST->head->next == NULL){   //Si la lista solo tiene un elemento
        free(LIST->head);        //Se libera el espacio que estaba ocupando el nodo cabeza
        LIST->head = NULL;      //El apuntador de la cabeza será nulo (Si no se hace esto por alguna razón se queda iterando infinito)
        LIST->size = 0; //Al finalizar la recursividad, no queda ningún nodo en la lista
    }else{  //Si la lista ya tiene elementos

        struct node *current_node = LIST->head;     //Se guarda la cabeza en un apuntador
        LIST->head = LIST->head->next;              //La cabeza de la lista será el siguiente nodo a la cabeza
        destroyNode(current_node);  //Se libera el espacio que ocupa la anterior cabeza

        clear(LIST);    //Se llama recursivamente al método

    }

}

bool contains(struct SimpleLinkedList *LIST, int this){   //Método para buscar un dato dentro de la lista

    if(isEmpty(LIST)){  // Caso de que la lista esté vacía (Para evitar errores)
        return false;
    }else{

        struct node *current_node = LIST->head;     //Nodo que irá iterando en la lista
        bool encontrado = false;    //Variable para saber si se encontró el objeto (iniclamente es false).

        while(current_node != NULL){  //Mientras que el nodo actual no sea NULL sigue iterando

            if(current_node->data == this){
                encontrado = true;  //Cambia el valor de la variable que registra si se encontró el objeto
                break;  //Rompe el while
            }

            //Si no se ha encontrado, se sigue iterando
            current_node = current_node->next;

        }

        return encontrado;  //Finalmente, retorna si lo encontró

    }

}

struct node* search(struct SimpleLinkedList *LIST, int this){   //Método para retornar el nodo que contiene un objeto dado

    if(contains(LIST, this)){ //Se verifica primero que la lista sí contenga el objeto
        struct node *current_node = LIST->head; //Nodo para iterar la lista

        while(current_node != NULL){  //Mientras que el nodo actual no sea NULL sigue iterando

            if(current_node->data == this){ //Si encuentra el objeto, rompe el ciclo
                break;
            }

            //Si no se ha encontrado, se sigue iterando
            current_node = current_node->next;

        }

        return current_node;    //Cuando encuentre el nodo, lo retorna

    }else{  //Si la lista no contiene el objeto, se retorna NULL
        return NULL;
    }
}

bool remove_element(struct SimpleLinkedList *LIST, int this){   //Método para eliminar el nodo que contiene un objeto dado

    if(isEmpty(LIST)){  //Si la lista está vacía
        return false;
    }else if(contains(LIST, this) == false){    //Si la lista no contiene el objeto
        return false;
    }else{  //En caso de que la lista NO ESTÉ VACÍA y SÍ CONTENGA EL OBJETO

        struct node *current_node = LIST->head;     //Nodo para iterar la lista
        struct node *before_node = NULL;    //Nodo auxiliar para poder "soltar" los enlaces

        while(current_node != NULL){    //Mientras que no llegue al final de la lista

            if(current_node->data == this){
                if(current_node == LIST->head){   //Si el nodo que contiene el objeto es la cabeza de la lista
                    LIST->head = LIST->head->next;  //La nueva cabeza será el nodo que estaba después de la anterior cabeza
                }
                else{   //En caso de que el nodo no sea la cabeza
                    before_node->next = current_node->next;
                }

                destroyNode(current_node);  //Al finalizar cualquiera de los casos, libera la memoria del nodo eliminado
                LIST->size--;   //Disminuye el size de la lista
                break;  //Rompe el cilclo para dejar de iterar
            }

            //Si no lo ha encontrado, sigue iterando
            before_node = current_node;
            current_node = current_node->next;

        }

        return true;

    }

}

void reverse(struct SimpleLinkedList *LIST, struct SimpleLinkedList *HERE){ //Se pasa la lista a revertir y la lista donde se guardará el resultado

    struct node *current = LIST->head;   //Nodo para iterar la lista original

    while(current != NULL){ //Se van guardando los datos en la otra lista, pero insertándolos siempre en la cabeza
        insertAtHead(HERE, current->data);
        current = current->next;
    }

}

void toArray(struct SimpleLinkedList *LIST, int* ARRAY){

    int index = 0;
    struct node *current = LIST->head;  //Nodo para iterar la lista

    while(current != NULL){
        ARRAY[index] = current->data;
        current = current->next;
        index++;
    }

}

void listToString(struct SimpleLinkedList *LIST){    //Método para imprimir toda la lista
    if(isEmpty(LIST)){  //Si la lista está vacía
        printf("La lista está vacía");
    }else{
        nodeToString(LIST->head);   //Se llama al método ToString() de la cabeza de la cola
    }
}
{% endblock %}

{% block table_content %}
<tr>
    <th scope="row">1</th>
    <td>Punteros en C:</td>
    <td>https://www.hackerrank.com/challenges/pointer-in-c/problem</td>
</tr>
<tr>
    <th scope="row">2</th>
    <td>Structs en C:</td>
    <td>https://youtu.be/CoW5NyFyGb4</td>
</tr>
<tr>
    <th scope="row">3</th>
    <td>Structs en C (con ejemplos):</td>
    <td>https://www.tutorialspoint.com/cprogramming/c_structures.htm</td>
</tr>
<tr>
    <th scope="row">4</th>
    <td>Guía de implementación lista simplemente enlazada en C</td>
    <td>https://youtu.be/NPmwuR4VbKk</td>
</tr>
<tr>
    <th scope="row">5</th>
    <td>Guía 2 de implementación lista enlazada en C (dividido en partes): </td>
    <td>https://youtu.be/_CjUucnAxYI</td>
</tr>
<tr>
    <th scope="row">6</th>
    <td>¿Cómo retornar un array de una función en C?</td>
    <td>https://youtu.be/WJO-obvMpFY</td>
</tr>
<tr>
    <th scope="row">7</th>
    <td>Memoria dinámica en C: Malloc y Free</td>
    <td>http://labsopa.dis.ulpgc.es/fso/cpp/intro_c/introc75.htm</td>
</tr>
{% endblock %}
